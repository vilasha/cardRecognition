package io.brainshells;

import javax.imageio.ImageIO;
import java.awt.*;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.util.HashMap;
import java.util.Map;
import java.util.Properties;
import java.util.stream.IntStream;

public class Main {

    public static void main(String[] args) throws IOException {
        String resDir = Thread.currentThread().getContextClassLoader().getResource("").getPath();

        Properties props = new Properties();
        props.load(new FileInputStream(resDir + "settings.properties"));
        final int background_gray = Integer.parseInt(props.getProperty("background_gray"));     // if we need to skip gray cards, set this value to -1
        final int bright_black = Integer.parseInt(props.getProperty("bright_black"));
        final int shadowed_black = Integer.parseInt(props.getProperty("shadowed_black"));
        // measured these coords and height with Windows Paint, coords of a cursor are on the bottom-left corner
        final int first_card_corner_x = Integer.parseInt(props.getProperty("first_card_corner_x"));
        final int first_card_corner_y = Integer.parseInt(props.getProperty("first_card_corner_y"));
        final int card_width = Integer.parseInt(props.getProperty("card_width"));
        final int card_height = Integer.parseInt(props.getProperty("card_height"));
        final int cards_padding = Integer.parseInt(props.getProperty("cards_padding"));
        final int border_padding = Integer.parseInt(props.getProperty("border_padding"));
        final int suit_top_x = Integer.parseInt(props.getProperty("suit_top_x"));
        final int suit_top_y = Integer.parseInt(props.getProperty("suit_top_y"));
        final int suit_width = Integer.parseInt(props.getProperty("suit_width"));
        final int suit_height = Integer.parseInt(props.getProperty("suit_height"));
        final int suit_distinguish_red_y = Integer.parseInt(props.getProperty("suit_distinguish_red_y"));
        final int suit_distinguish_black_x = Integer.parseInt(props.getProperty("suit_distinguish_black_x"));
        final int suit_distinguish_black_y = Integer.parseInt(props.getProperty("suit_distinguish_black_y"));
        final int face_top_x = Integer.parseInt(props.getProperty("face_top_x"));
        final int face_top_y = Integer.parseInt(props.getProperty("face_top_y"));
        final int face_width = Integer.parseInt(props.getProperty("face_width"));
        final int face_height = Integer.parseInt(props.getProperty("face_height"));

        Map<String, double[][]> probabilityMap = new HashMap<>();
        // Read all sprites generated by the line 108, at the moment it is commented out
        File spritesDir = new File(resDir + "sprites");
        for (final File fileEntry : spritesDir.listFiles()) {
            BufferedImage sprite = ImageIO.read(fileEntry);
            int[][] colorMap = new int[face_width][face_height];
            IntStream.range(0, face_width)
                    .forEach(x -> IntStream.range(0, face_height)
                            .forEach(y -> colorMap[x][y] = sprite.getRGB(x, y) == -1 ? 0 : 1));

            double[][] blackProbability = new double[face_width][face_height];
            for (int x = 2; x < face_width - 4; x++)
                for (int y = 2; y < face_height - 4; y++) {
                    blackProbability[x][y] = 1.0 * colorMap[x][y]
                            + 0.5 * (colorMap[x - 1][y - 1] + colorMap[x][y - 1] + colorMap[x + 1][y - 1]
                                    + colorMap[x - 1][y] + colorMap[x + 1][y]
                                    + colorMap[x - 1][y] + colorMap[x][y] + colorMap[x + 1][y]) / 8
                            + 0.25 * (colorMap[x - 2][y - 2] + colorMap[x - 1][y - 2] + colorMap[x][y - 2] + colorMap[x + 1][y - 2] + colorMap[x + 2][y - 2]
                                    + colorMap[x - 2][y - 1] + colorMap[x + 2][y - 1]
                                    + colorMap[x - 2][y] + colorMap[x + 2][y]
                                    + colorMap[x - 2][y + 1] + colorMap[x + 2][y + 1]
                                    + colorMap[x - 2][y + 2] + colorMap[x - 1][y + 2] + colorMap[x][y + 2]
                                            + colorMap[x + 1][y + 2] + colorMap[x + 2][y + 2]) / 16;
                }
            probabilityMap.put(fileEntry.getName().replace(".png", ""), blackProbability);
        }

        File imgDir = new File(args[0]);
        for (final File fileEntry : imgDir.listFiles()) {
            BufferedImage img = ImageIO.read(fileEntry);
            StringBuilder recognized = new StringBuilder();

            for (int i = 0; i < 5; i++) {
                String suitValue, faceValue = "";
                BufferedImage card = img.getSubimage(
                        first_card_corner_x + i * (card_width + cards_padding), first_card_corner_y,
                        card_width, card_height);
                int emptyPixel = card.getRGB(card_width - border_padding, border_padding);
                // If the empty pixel is not White, there is no card on this spot
                if (emptyPixel != -1 && emptyPixel != background_gray)
                    continue;

                // Get a suit of the card
                BufferedImage suit = card.getSubimage(suit_top_x, suit_top_y, suit_width, suit_height);
                int suitCenter = suit.getRGB(suit_width / 2, suit_height / 2);
                if (suitCenter == bright_black || suitCenter == shadowed_black) {          // black
                    int leftGapPixel = suit.getRGB(suit_distinguish_black_x, suit_distinguish_black_y);
                    suitValue = (leftGapPixel == -1 || leftGapPixel == background_gray) ? "clubs" : "spades";
                } else {     //red or dark red
                    int topMiddlePixel = suit.getRGB(suit_width / 2, suit_distinguish_red_y);
                    suitValue = (topMiddlePixel == -1 || topMiddlePixel == background_gray) ? "hearts" : "diamonds";
                }

                // Get a face of the card
                BufferedImage faceColored = card.getSubimage(face_top_x, face_top_y, face_width, face_height);

                // if the card is shadowed, enlighten the whole block, otherwise the number becomes too thick and sometimes causes a recognition error
                if (emptyPixel == background_gray)
                    IntStream.range(0, face_width).forEach(x -> IntStream.range(0, face_height)
                            .forEach(y -> faceColored.setRGB(x, y, faceColored.getRGB(x, y) + 0x444444)));

                BufferedImage face = new BufferedImage(face_width, face_height, BufferedImage.TYPE_BYTE_BINARY);
                Graphics2D graphic = face.createGraphics();
                graphic.drawImage(faceColored, 0, 0, Color.WHITE, null);
                graphic.dispose();
//                ImageIO.write(face, "png", new File(resDir + "/res/face" + i + ".png"));  // Uncomment this line to generate new sprites for "sprites" folder
                double maxMatchKoeff = 0;
                for (String possibleValue : probabilityMap.keySet()) {
                    double[][] probabilityCurrent = probabilityMap.get(possibleValue);
                    double matchKoeff = 0;
                    for (int x = 2; x < face_width - 4; x++) {
                        for (int y = 2; y < face_height - 4; y++) {
                            int pixel = (face.getRGB(x, y) == -1 || face.getRGB(x, y) == background_gray) ? 0 : 1;
                            matchKoeff += pixel == 0 ? 1 - probabilityCurrent[x][y] : probabilityCurrent[x][y];
                        }
                    }
                    if (matchKoeff > maxMatchKoeff) {
                        faceValue = possibleValue;
                        maxMatchKoeff = matchKoeff;
                    }
                }
                recognized.append(faceValue.toUpperCase()).append(suitValue.charAt(0));
            }
//            BufferedImage table = img.getSubimage(first_card_corner_x, first_card_corner_y, (card_width + cards_padding) * 5, card_height);
//            ImageIO.write(table, "png", new File(resDir + "res/" + recognized + ".png"));
            System.out.println(fileEntry.getName() + " - " + recognized.toString());
        }
    }
}